# Проект администрирования задач и учета времени 


## Сборка и разработка:
* Установите .net framework 4.8 и .net core 3.1
* Для разработки проекта мы используем Visual Studio 2019 и следующие расширения: Xalm Styler, Roslinator 2019 и по желанию CodeMaid.

## Документация

### Система модулей

### Security
* [Архитектура модулей безопасности](Docs/Security/Architecture.md)
* [Настройка](Docs/Security/Configuration.md)


# Соглашения по кодированию:
Все правила имеют преффикс, определяющие их строгость:
* **D** - Do - Обязательно для применения. Не стоит игнорировать это правило.
* **C** - CONSIDER - Правило рекомендуется, но оно применимо не ко всем ситуациям.
* Ниже описаны правила, которые не исследуются в статических анализаторах кода. По состоянию на начало 2020 года для анализа кода в решении используется Roslynator 2019. Установите его, если он не установлен в Visual Studio. Для создания кода применяется Visual Studio 2019. Также в решении уже есть .editorconfig файл, содержашщий многие правила написания кода.

### 1. Visual Studio, решение, проект:
* **D1000** Используйте Package Reference для nuget пакетов вместо Packages.config
* **C1001** Тщательно заполняйте атрибуты в файле AssemblyInfo.cs
* **D1002** Наименование проекта создавайте по шаблону: Adani.НазваниеРешение.ПапкаПроекта.Название. Например: Adani.Medicine.Images.Dicom. Папка проекта семантически означает некую функциональность решения.
* **D1003** Создавайте пространство имен так, чтобы оно соответствовало шаблону: НазваниеПроекта.НазваниеКласса. Если создаете несколько классов с разным пространством имен - поместите их в проект НазваниеПроекта.Core. Пространство имен, как и название сборки должно отражать основную функциональность модуля.
* **C1004** Для новых проектов используйте: .Net Framework 4.8 если нужна совместимость со сторонними SDK, .Net Standart 2.0 если проект будет использоваться как для .Net Framework 4.8 так и для .Net Core, .Net Core 3.0 для остальных проектов


### 2. Написание документации:
* **D2000** Пишите документацию на английском языке. Внимательно изучите глоссарий АДАНИ и используйте его как для дкументации, так и для наименование классов.
* **C2001** Главная документация проекта это код. Изучите книгу Стива МакКоннелла "Совершенный код". Попробуйте прочитать свой код. Если вы читаете его как увлекательный рассказ - он хороший.
* **C2002** Используйте  #region/ednregion для выделения законченных блоков класса, например для выделения имплементации интерфейса. Однако, много #region/ednregion тоже много. И если вы решили вставить блок внутри метода - подумайте, может этот метод слишком много себе позволяет.
* **C2003** Используйте комментарии правильно. Оставляйте комментарии только там, где не совсем ясно, что делает код. При этом, пишите не то, что делает код, а почему он так делает. Размещайте комментарий на отдельной строке, а не в конце строки кода. Текст комментария начинайте с заглавной буквы и завершайте его точкой. Между разделителем комментария и текстом комментария вставляйте один пробел.

Плохо:
```csharp
foreach (var error in errors)
{
    LastErrors.Add(error);//add each error in collection
}
```
Хорошо:
```csharp
// To detect redundant calls.
private bool _disposedValue = false;
```
* **D2004** Используйте inline документацию. Создавайте inline xml документацию обязательно для каждого публичного члена класса. Используйте всю мощь этого инструмента. Простое ```summary``` не подойдет.

Плохо:
```csharp
 /// <summary>
/// Clears the hardware errors.
/// </summary>
public async Task<bool> ClearHardwareErrorsAsync()
{
    ...
}
```

Хорошо:
```csharp
/// <summary>
/// Adds the specified task  to queue
/// </summary>
/// <typeparam name="T">Task result</typeparam>
/// <param name="task">The task.</param>
/// <returns>Completed Task</returns>
public Task<T> Enqueue<T>(Func<Task<T>> task)
{
    ...
}
```
* **D2005** Не забывайте комментировать XAML код. Так будет проще его понимать.

### 3. Архитектура, паттерны:
* **C3001** Помните про базовые архитектурные принципы. **The Principle of Least Surprise.** «Принцип наименьшего удивления». Не пишите крутой код. Не ищите вычурных решений. Linq хорош, но иногда его сложно читать. Битовая магия хороша, но только если нужна производительность. Помните, что ваш код будут сопровождать другие программисты.
**Keep It Simple Stupid (или KISS).** Дословно – «Делай это проще, идиот». Для решения поставленных задач необходимо выбирать наиболее простое решение.
**You Ain’t Gonne Need It (или YAGNI).** «Вам это не понадобится». Не нужно плодить избыточную функциональность класса или модуля без надобности. Этакая «бритва Оккама« для программистов.
**Don’t Repeat Yourself (или DRY).** «Не повторяйся». Если вы выделили весь код класса и нажали ctrl+c, остановитель. Самое время вспомнить это правило. А как же наследование? А полиморфизм?
* **C3002** При проектировании программы используйте принципы SOLID везде, где это возможно. Каждый раз создавая новый класс или модуль убедитесь, что он не противоречит принципам. Поленитесь сейчас - потеряете время потом.
* **C3003** Избегайте статических классов. Часто это свидетельствует о неверном применение паттерна "Окружающий контекс". Исключение - создание класса с методами расширений.
* **C3004** Класс должен иметь состояние, определяемое данными и поведение определяемое методами и событиями. Класс не должен владеть чужими данными и иметь чужого поведения. Как исключение можно принять классы обертки и классы, реализующие шаблон DTO (Data Transfer Objects).
* **C3005** По возможности, при работе с библиотеками, написанными на другом языке, запускайте работу модуля в другом процессе. Например, используя с++ библиотеку через P/Invoke или delphi модуль через com взаимодействие, создайте для управляемой обертки отдельный процесс. Для обмена данными используйте любые способы межпроцессного взаимодействия. Такой подход позволит избежать краха основного приложения при ошибке в неуправляемой библиотеке. Проблема в том, что ошибка в неуправляемом коде часто связана с повреждением памяти и продолжение работы хоста невозможна).



### 4. Проектирование членов классов:
* **C4001** Создавайте новые экземпляры класса по принципу «Все или ничего». Созданный объект должен быть полностью функционален. Все открытые свойства должны быть проинициализированы. Плохой пример - создание изображения в котором нет изображения, и которе появится только после вызова метода ```LoadFromFile(string fileName)```.
* **C4002**  Используйте условные операторы с умом. Если вам захотелось написать switch или вы пишите уже третий if в методе - сходите попейте чаю. Скорее всего нужно вспомнить о полиморфизме.
* **D4005**  Не используйте асинхронные методы, возвращающие void.
* **D4006**  Не используйте public и internal поля. Это должны быть свойства. Помните об инкапсуляции.
* **D4007** Не скрывайте унаследованные элементы за ключевым словом new. Это противоречит полиморфизму. Скорее всего у вас неверная иерархия наследования.
* **D4008** Свойства и методы класса должны иметь возможность быть установленными в любом порядке. Есть случаи, когда пользователь должен вызвать методы или установить свойства в определенном порядке. В таком случае рассмотрите возможность применения шаблона "Шаблонный метод" или "Состояние". Почитайте, что такое машина состояний.  Не нужно указывать порядок работы в справке и надеяться, что клиент будет ее читать.
* **C4009** Используйте свойства чтобы вернуть уже имеющиеся данные. В остальных случаях используйте метод.
* **D4010** С умом возвращайте коллекции из побличных методов и свойств. Возвращайте интерфейс коллекции вместо конкретного класса. Это может быть IEnumerable или ICollection. Все зависит от последующего использования коллекции, возвращаемого методом или свойством. Однако с осторожностью возвращайте IQueryable. Хотя на самом деле это нужно в очень редких случаях. Если необходимо ограничить клиенту изменение коллекции - используйте ReadOnlyCollections, например IReadOnlyCollection. Просто убрать сеттер из свойства недостаточно.
* **С4011** Возвращаемые членами класса значения ссылочного типа не должны быть равны null. Это крайне неожиданно для пользователя. Или выбросте Exception, или выдайте значение. Может быть вам понравится монада "Maybe". Если возвращается коллекция, так верните ее пустой. А еще можно сделать метод ```bool TryВашМетод(out возвращаемое значение)```. Начиная C# 7.0 можно использовать out переменные, и глаза уже не кровоточат от такого шаблона.
* **C4012** Принимайте в качестве параметров методов минимально необходимый объект. В примере ниже мы используем только параметры устройства для его создания, но передаем в метод все параметры приложения. Такой подход только кажется безобидным. На самом деле мы не проверяем свойство "DeviceConfiguration" на null.

Плохо:
```csharp
public void Initialization(IConfiguration configuration)
{
    if (configuration!=null)
    {
    var device = new Device(configuration.DeviceConfiguration);
    }
}
```
Хорошо:
```csharp
public void Initialization(IDeviceConfiguration deviceConfiguration)
{
    if (deviceConfiguration!=null)
    {
    var device = new Device(deviceConfiguration);
    }
}
```

* **C4013** Используйте типы из вашей предметной области вместо стандартных типов. Например, для указания напряжения на генераторе используйте не double, а свой собственный тип с проверкой диапазона значений и так далее.
* **C4014**  Не злоупотребляйте использованием аргумента типа boolean в методах. Это плохо читается.

Плохо:
```csharp
public void Initialization(bool readSubDirectories)
{
    ...
}

public void Start()
{
    Initialization(true);
}
```
Лучше:
```csharp
public void Initialization(bool readSubDirectories)
{
    ...
}

public void Start()
{
    Initialization(readSubDirectories:true);
}
```

Хорошо:
```csharp
public void Initialization(FilesReadMode filesReadMode)
{
    ...
}

public void Start()
{
    Initialization(FilesReadMode.ReadSubDirectories);
}
```
* **C4015**  Метод должен иметь одну точку выхода. В таком случае он хорошо читается и отладка происходит без боли.

Плохо:
```csharp
public static bool IsDirectory(this ZipArchiveEntry entry)
        {
            if (entry.FullName.EndsWith(Path.DirectorySeparatorChar.ToString(),
                StringComparison.InvariantCultureIgnoreCase))
            {
                return true;
            }
            else if(entry.FullName.EndsWith(Path.AltDirectorySeparatorChar.ToString(),
                StringComparison.InvariantCultureIgnoreCase))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
```

Хорошо:
```csharp
public static bool IsDirectory(this ZipArchiveEntry entry)
        {
            var result = false;

            var lastChar = entry.FullName.Last();

            if (lastChar.Equals(Path.DirectorySeparatorChar) ||
                lastChar.Equals(Path.AltDirectorySeparatorChar))
            {
                result = true;
            }

            return result;
        }
```


* В разработке... Подходы к созданию классов, членов классов. Асинхронные операции.


### 5. Оформление кода и наименование:
* **D5001** Используйте скобки с оператором if-else, даже если блок содержит одну инструкцию.

Плохо:
```csharp
 if (index<0)
 secondIndex=1;
```

Хорошо:
```csharp
if (index<0)
{
 secondIndex=1;
}
```
* **D5002** Оставляйте отступы между блоками кода для повышение удобочитаемости.

Плохо:
```csharp
  public async Task<bool> SetExposureParametersAsync(ExposureParameters exposureParameters)
        {  _logger.Trace("Start generator SetExposureParametersAsync");
            var validatedExposureParameters = new SpellmanPmxValidatedExposureParameters().Validate(exposureParameters);
            _logger.Trace("Start generator SetExposureParametersAsync");
            return await SetExposureSettingsCommandAsync(validatedExposureParameters);
        }
```

Хорошо:
```csharp
  public async Task<bool> SetExposureParametersAsync(ExposureParameters exposureParameters)
        {
            _logger.Trace("Start generator SetExposureParametersAsync");

            var validatedExposureParameters = new SpellmanPmxValidatedExposureParameters().Validate(exposureParameters);

            _logger.Trace("Start generator SetExposureParametersAsync");

            return await SetExposureSettingsCommandAsync(validatedExposureParameters);
        }
```

* **С5003** Назначайте переменным, именам членов типов и самим типам внятные, легкочитаемые наименования. Конечно, если имя занимает половину экрана, это плохо для читаемости кода. Однако наименование вроде "db", "ofs", "SetToDst" тоже сложно понять. Приходится добавлять коментарии. Назначайте такие наименования, которые не требуют коментариев или документации для понимания. Избегайте использования цифр. Осторожно с сокращениями и акронимами.

Плохо:
```csharp
  public abstract byte Copy(byte[] src, byte[] dst, int offs, int offs1, int c );
```

Хорошо:
```csharp
 public abstract byte CopyBytes(byte[] source, byte[] destination, int sourceOffset, int destinationOffset, int bytesCount);
```

Есть и исключения, например параметры linq выражений:
 ```csharp
 var minHeight = Bags.Min(v=>v.Height);
```

* **D5004** При создании класса в файле используйте следующий порядок расположения членов:
 ```csharp
//Публичные константы.
public const int Radius=100;

//Приватные константы
private const int _height=20;

//Приватные поля
private double _lenght;

//События
public event EventHandler<int> Moved;

//Свойства
public int Weight{get;set;}

//Конструкторы
public MyClass()
{...}

//Публичные методы
public void Update()
{...}

//Internal методы
internal void Calculate()
{...}

//Protected методы
protected override int GetWeight()
{...}

//Приватные методы
private void Initialize()
{...}
```
Выделяйте участок класса с имплементацией интерфейса или абстрактного класса в region, в который включайте и публичные члены и приватные. Но соблюдайте ту же последовательность. Пометьте в названии региона какой интерфейс вы реализовали.
```csharp
#region IEnumerable
    public IEnumerator<Marker> GetEnumerator()
    {
        return _graphicObjects.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return ((IEnumerable)_graphicObjects).GetEnumerator();
    }
#endregion
```
Если у класса несколько конструкторов - поместите их в region.
В разработке...наименование классов и членов, наименование параметров


### 6. Рекомендации по производительности и оптимизации:
* **C6001** Объективно оценивайте выбор между скоростью и сопровождаемостью кода. Часто сопровождаемость важнее скорости.
* **C6002** При написании кода сразу определите требования к быстродействию для конкретной конфигурации компьютера. В процессе написания тестов  можно создать один для проверки быстродействия для алгоритма. Проверку быстродействия необходимо проверять только для сборок release.
* **C6003** Для операций и задач, длящихся более 50 миллисекунд используйте асинхронные операции. С точки зрения пользователя задержка в 50 миллисекунд является уже заметной для восприятия.
* **D6004** Асинхронный код "цветной". Это означает, что при использовании асинхронного API все дерево вызовов тоже должно быть асинхронное. Не вызывайте асинхронное API  в синхронном коде. Не используйте Task.Wait() или Task.Result в синхронном коде в однопоточном окружении (в UI, например). Можете нарваться на дедлок.
* **С6005** Всегда четко понимайте в каком потоке выполняется код. При использовании асинхронного метода он начинается в вызывающем потоке и как правило в нем оканчивается. Поток при этом не блокируется, но при долгой операции происходит частое переключение этого потока, что не очень хорошо сказывается на производительности. Используйте Task.Run() для долгих операций. В таком случае поток возмется из пула потока.
* **C6010** Всегда помните про «О большое» при написании алгоритма. Изучите концепцию временной и пространственной сложности и будете понимать быстро или медленно работает алгоритм еще до того, как вы его создали. При создании алгоритмов помните не только про временную сложность, но и про потребляемый объем оперативной памяти и время процессора. Часто один и тот же АРМ обслуживает и работу с оборудованием, и искусственный интеллект. Будет очень грустно, если в процессе томосинтеза вы заблокируете процессор и он пропустит сообщение с ошибкой от оборудования.


### 7. Рекомендации по использованию фреймворка:
* **C7001** Используйте исключения вместо кодов возврата. Исключение это не сообщение об ошибке, а возможная исключительная ситуация. Поэтому при создании методов учитывайте все возможные сценарии. И во всех побочных сценариях выбрасывайте осмыссленное исключение. Собственные исключения нужно создавать либо при крайней необходимости, либо при создании собственной библиотеки. При этом линия наследования исключений должна повтарять пространство имен. Используйте собственные исключения, когда нужно объединить несколько семантически родственных исключений в одно. Если метод выбрасывает исключение - создайте inline документацию, где подробно опишите в каких ситуация возникает исключение.
* **C7002** Не выбрасывайте исключения в свойствах и событиях. Исключения только для методов и конструкторов.
* **C7003** Не игнорируйте чужие исключения путем обработки  общих исключений. Пустое отлавливание Exception просто проглатывает ошибки.
* **C7004** Использование try-catch в цикле не самая хорошая идея. Слишком много накладных расходов. Используйте по возможности шаблон "Tester-Doer".
* **C7005** Помните об особенностях обработки исключений в асинхронном коде. Исключения, которые возникают в пределах блоков async/awaitи внутри Task, распространяются на задачу, которая ожидает выполнение этих блоков
Исключения, которые возникли в коде, предшествующем async/await и Task, распространяются на вызывающий код. Методы Task.WhenAll и Task.WhenAny могут вернуть AggregateException.
* **C7006** Всегда проверяйте делегат обработчика событий на null. Тоже самое касается и коллбеков.


### 8. Рекомендации по автоматизированному тестированию:
* **D8001** При тестировании метода определите и напишите тесты для нормальных случаев, крайних случаев, null и недопустимого параметра, аномального параметра (данные неверны). Определите ожидаемый результат во всех случаях и проверьте его.

### 9. Работа с системой контроля версий:
* **C9001** Изучите идеологию и команды git. Хорошая книга для этого "Git для профессионального программиста" тов. С. Чакона (есть в литературе).
* **D9002** У каждого разработчика обязательно должны быть правильно прописаны фамилия имя и e-mail.
* **D9003** На проекты все разработчики используют модель ветвления [Git-flow](https://blogs.endjin.com/2015/01/using-smartgit-to-follow-the-gitflow-branching-and-workflow-model). Если ваша работа затрагивает пространство имен других разработчиков и работа будет более 8-ми часов - создавайте новую ветку фичи. При этом не забывайте каждый день брать изменения из ветки Develop.
* **D9004** Делайте коммиты как можно чаще, минимум один в конце рабочего дня и заливайте локальные коммиты на сервер. Так вы убережете себя от потери сделанной работы. Коммиты необходимо писать на английском языке.
* Формат коммита следующий:

``` CSharp
[код] Краткое описание коммита

Подробное описание коммита. Здесь нужно написать дополнительную информацию, если она необходима.
А необходима она, если например коммит устраняет баг, или краткое название не очень отражает суть.
```

* Коды:
``` CSharp
 [+] Добавление функционала
 [-] Удаление функционала
 [~] Незначительные изменения
 [bug] Устранение ошибки
 [Test] Создание тестов
 [Doc] Создание документации
```
